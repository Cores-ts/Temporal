// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/RTradeLtd/database/models"
)

type FakeUsageManager struct {
	FindByUserNameStub        func(string) (*models.Usage, error)
	findByUserNameMutex       sync.RWMutex
	findByUserNameArgsForCall []struct {
		arg1 string
	}
	findByUserNameReturns struct {
		result1 *models.Usage
		result2 error
	}
	findByUserNameReturnsOnCall map[int]struct {
		result1 *models.Usage
		result2 error
	}
	NewUsageEntryStub        func(string, models.DataUsageTier) (*models.Usage, error)
	newUsageEntryMutex       sync.RWMutex
	newUsageEntryArgsForCall []struct {
		arg1 string
		arg2 models.DataUsageTier
	}
	newUsageEntryReturns struct {
		result1 *models.Usage
		result2 error
	}
	newUsageEntryReturnsOnCall map[int]struct {
		result1 *models.Usage
		result2 error
	}
	UpdateTierStub        func(string, models.DataUsageTier) error
	updateTierMutex       sync.RWMutex
	updateTierArgsForCall []struct {
		arg1 string
		arg2 models.DataUsageTier
	}
	updateTierReturns struct {
		result1 error
	}
	updateTierReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUsageManager) FindByUserName(arg1 string) (*models.Usage, error) {
	fake.findByUserNameMutex.Lock()
	ret, specificReturn := fake.findByUserNameReturnsOnCall[len(fake.findByUserNameArgsForCall)]
	fake.findByUserNameArgsForCall = append(fake.findByUserNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindByUserName", []interface{}{arg1})
	fake.findByUserNameMutex.Unlock()
	if fake.FindByUserNameStub != nil {
		return fake.FindByUserNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findByUserNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageManager) FindByUserNameCallCount() int {
	fake.findByUserNameMutex.RLock()
	defer fake.findByUserNameMutex.RUnlock()
	return len(fake.findByUserNameArgsForCall)
}

func (fake *FakeUsageManager) FindByUserNameCalls(stub func(string) (*models.Usage, error)) {
	fake.findByUserNameMutex.Lock()
	defer fake.findByUserNameMutex.Unlock()
	fake.FindByUserNameStub = stub
}

func (fake *FakeUsageManager) FindByUserNameArgsForCall(i int) string {
	fake.findByUserNameMutex.RLock()
	defer fake.findByUserNameMutex.RUnlock()
	argsForCall := fake.findByUserNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUsageManager) FindByUserNameReturns(result1 *models.Usage, result2 error) {
	fake.findByUserNameMutex.Lock()
	defer fake.findByUserNameMutex.Unlock()
	fake.FindByUserNameStub = nil
	fake.findByUserNameReturns = struct {
		result1 *models.Usage
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageManager) FindByUserNameReturnsOnCall(i int, result1 *models.Usage, result2 error) {
	fake.findByUserNameMutex.Lock()
	defer fake.findByUserNameMutex.Unlock()
	fake.FindByUserNameStub = nil
	if fake.findByUserNameReturnsOnCall == nil {
		fake.findByUserNameReturnsOnCall = make(map[int]struct {
			result1 *models.Usage
			result2 error
		})
	}
	fake.findByUserNameReturnsOnCall[i] = struct {
		result1 *models.Usage
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageManager) NewUsageEntry(arg1 string, arg2 models.DataUsageTier) (*models.Usage, error) {
	fake.newUsageEntryMutex.Lock()
	ret, specificReturn := fake.newUsageEntryReturnsOnCall[len(fake.newUsageEntryArgsForCall)]
	fake.newUsageEntryArgsForCall = append(fake.newUsageEntryArgsForCall, struct {
		arg1 string
		arg2 models.DataUsageTier
	}{arg1, arg2})
	fake.recordInvocation("NewUsageEntry", []interface{}{arg1, arg2})
	fake.newUsageEntryMutex.Unlock()
	if fake.NewUsageEntryStub != nil {
		return fake.NewUsageEntryStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.newUsageEntryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageManager) NewUsageEntryCallCount() int {
	fake.newUsageEntryMutex.RLock()
	defer fake.newUsageEntryMutex.RUnlock()
	return len(fake.newUsageEntryArgsForCall)
}

func (fake *FakeUsageManager) NewUsageEntryCalls(stub func(string, models.DataUsageTier) (*models.Usage, error)) {
	fake.newUsageEntryMutex.Lock()
	defer fake.newUsageEntryMutex.Unlock()
	fake.NewUsageEntryStub = stub
}

func (fake *FakeUsageManager) NewUsageEntryArgsForCall(i int) (string, models.DataUsageTier) {
	fake.newUsageEntryMutex.RLock()
	defer fake.newUsageEntryMutex.RUnlock()
	argsForCall := fake.newUsageEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUsageManager) NewUsageEntryReturns(result1 *models.Usage, result2 error) {
	fake.newUsageEntryMutex.Lock()
	defer fake.newUsageEntryMutex.Unlock()
	fake.NewUsageEntryStub = nil
	fake.newUsageEntryReturns = struct {
		result1 *models.Usage
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageManager) NewUsageEntryReturnsOnCall(i int, result1 *models.Usage, result2 error) {
	fake.newUsageEntryMutex.Lock()
	defer fake.newUsageEntryMutex.Unlock()
	fake.NewUsageEntryStub = nil
	if fake.newUsageEntryReturnsOnCall == nil {
		fake.newUsageEntryReturnsOnCall = make(map[int]struct {
			result1 *models.Usage
			result2 error
		})
	}
	fake.newUsageEntryReturnsOnCall[i] = struct {
		result1 *models.Usage
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageManager) UpdateTier(arg1 string, arg2 models.DataUsageTier) error {
	fake.updateTierMutex.Lock()
	ret, specificReturn := fake.updateTierReturnsOnCall[len(fake.updateTierArgsForCall)]
	fake.updateTierArgsForCall = append(fake.updateTierArgsForCall, struct {
		arg1 string
		arg2 models.DataUsageTier
	}{arg1, arg2})
	fake.recordInvocation("UpdateTier", []interface{}{arg1, arg2})
	fake.updateTierMutex.Unlock()
	if fake.UpdateTierStub != nil {
		return fake.UpdateTierStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateTierReturns
	return fakeReturns.result1
}

func (fake *FakeUsageManager) UpdateTierCallCount() int {
	fake.updateTierMutex.RLock()
	defer fake.updateTierMutex.RUnlock()
	return len(fake.updateTierArgsForCall)
}

func (fake *FakeUsageManager) UpdateTierCalls(stub func(string, models.DataUsageTier) error) {
	fake.updateTierMutex.Lock()
	defer fake.updateTierMutex.Unlock()
	fake.UpdateTierStub = stub
}

func (fake *FakeUsageManager) UpdateTierArgsForCall(i int) (string, models.DataUsageTier) {
	fake.updateTierMutex.RLock()
	defer fake.updateTierMutex.RUnlock()
	argsForCall := fake.updateTierArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUsageManager) UpdateTierReturns(result1 error) {
	fake.updateTierMutex.Lock()
	defer fake.updateTierMutex.Unlock()
	fake.UpdateTierStub = nil
	fake.updateTierReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUsageManager) UpdateTierReturnsOnCall(i int, result1 error) {
	fake.updateTierMutex.Lock()
	defer fake.updateTierMutex.Unlock()
	fake.UpdateTierStub = nil
	if fake.updateTierReturnsOnCall == nil {
		fake.updateTierReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTierReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUsageManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findByUserNameMutex.RLock()
	defer fake.findByUserNameMutex.RUnlock()
	fake.newUsageEntryMutex.RLock()
	defer fake.newUsageEntryMutex.RUnlock()
	fake.updateTierMutex.RLock()
	defer fake.updateTierMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUsageManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

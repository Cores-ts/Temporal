// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/gcash/bchwallet/rpc/walletrpc"
	"google.golang.org/grpc"
)

type FakeWalletServiceClient struct {
	AccountNotificationsStub        func(context.Context, *walletrpc.AccountNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_AccountNotificationsClient, error)
	accountNotificationsMutex       sync.RWMutex
	accountNotificationsArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.AccountNotificationsRequest
		arg3 []grpc.CallOption
	}
	accountNotificationsReturns struct {
		result1 walletrpc.WalletService_AccountNotificationsClient
		result2 error
	}
	accountNotificationsReturnsOnCall map[int]struct {
		result1 walletrpc.WalletService_AccountNotificationsClient
		result2 error
	}
	AccountNumberStub        func(context.Context, *walletrpc.AccountNumberRequest, ...grpc.CallOption) (*walletrpc.AccountNumberResponse, error)
	accountNumberMutex       sync.RWMutex
	accountNumberArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.AccountNumberRequest
		arg3 []grpc.CallOption
	}
	accountNumberReturns struct {
		result1 *walletrpc.AccountNumberResponse
		result2 error
	}
	accountNumberReturnsOnCall map[int]struct {
		result1 *walletrpc.AccountNumberResponse
		result2 error
	}
	AccountsStub        func(context.Context, *walletrpc.AccountsRequest, ...grpc.CallOption) (*walletrpc.AccountsResponse, error)
	accountsMutex       sync.RWMutex
	accountsArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.AccountsRequest
		arg3 []grpc.CallOption
	}
	accountsReturns struct {
		result1 *walletrpc.AccountsResponse
		result2 error
	}
	accountsReturnsOnCall map[int]struct {
		result1 *walletrpc.AccountsResponse
		result2 error
	}
	BalanceStub        func(context.Context, *walletrpc.BalanceRequest, ...grpc.CallOption) (*walletrpc.BalanceResponse, error)
	balanceMutex       sync.RWMutex
	balanceArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.BalanceRequest
		arg3 []grpc.CallOption
	}
	balanceReturns struct {
		result1 *walletrpc.BalanceResponse
		result2 error
	}
	balanceReturnsOnCall map[int]struct {
		result1 *walletrpc.BalanceResponse
		result2 error
	}
	ChangePassphraseStub        func(context.Context, *walletrpc.ChangePassphraseRequest, ...grpc.CallOption) (*walletrpc.ChangePassphraseResponse, error)
	changePassphraseMutex       sync.RWMutex
	changePassphraseArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.ChangePassphraseRequest
		arg3 []grpc.CallOption
	}
	changePassphraseReturns struct {
		result1 *walletrpc.ChangePassphraseResponse
		result2 error
	}
	changePassphraseReturnsOnCall map[int]struct {
		result1 *walletrpc.ChangePassphraseResponse
		result2 error
	}
	CreateTransactionStub        func(context.Context, *walletrpc.CreateTransactionRequest, ...grpc.CallOption) (*walletrpc.CreateTransactionResponse, error)
	createTransactionMutex       sync.RWMutex
	createTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.CreateTransactionRequest
		arg3 []grpc.CallOption
	}
	createTransactionReturns struct {
		result1 *walletrpc.CreateTransactionResponse
		result2 error
	}
	createTransactionReturnsOnCall map[int]struct {
		result1 *walletrpc.CreateTransactionResponse
		result2 error
	}
	CurrentAddressStub        func(context.Context, *walletrpc.CurrentAddressRequest, ...grpc.CallOption) (*walletrpc.CurrentAddressResponse, error)
	currentAddressMutex       sync.RWMutex
	currentAddressArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.CurrentAddressRequest
		arg3 []grpc.CallOption
	}
	currentAddressReturns struct {
		result1 *walletrpc.CurrentAddressResponse
		result2 error
	}
	currentAddressReturnsOnCall map[int]struct {
		result1 *walletrpc.CurrentAddressResponse
		result2 error
	}
	DownloadPaymentRequestStub        func(context.Context, *walletrpc.DownloadPaymentRequestRequest, ...grpc.CallOption) (*walletrpc.DownloadPaymentRequestResponse, error)
	downloadPaymentRequestMutex       sync.RWMutex
	downloadPaymentRequestArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.DownloadPaymentRequestRequest
		arg3 []grpc.CallOption
	}
	downloadPaymentRequestReturns struct {
		result1 *walletrpc.DownloadPaymentRequestResponse
		result2 error
	}
	downloadPaymentRequestReturnsOnCall map[int]struct {
		result1 *walletrpc.DownloadPaymentRequestResponse
		result2 error
	}
	FundTransactionStub        func(context.Context, *walletrpc.FundTransactionRequest, ...grpc.CallOption) (*walletrpc.FundTransactionResponse, error)
	fundTransactionMutex       sync.RWMutex
	fundTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.FundTransactionRequest
		arg3 []grpc.CallOption
	}
	fundTransactionReturns struct {
		result1 *walletrpc.FundTransactionResponse
		result2 error
	}
	fundTransactionReturnsOnCall map[int]struct {
		result1 *walletrpc.FundTransactionResponse
		result2 error
	}
	GetTransactionsStub        func(context.Context, *walletrpc.GetTransactionsRequest, ...grpc.CallOption) (*walletrpc.GetTransactionsResponse, error)
	getTransactionsMutex       sync.RWMutex
	getTransactionsArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.GetTransactionsRequest
		arg3 []grpc.CallOption
	}
	getTransactionsReturns struct {
		result1 *walletrpc.GetTransactionsResponse
		result2 error
	}
	getTransactionsReturnsOnCall map[int]struct {
		result1 *walletrpc.GetTransactionsResponse
		result2 error
	}
	ImportPrivateKeyStub        func(context.Context, *walletrpc.ImportPrivateKeyRequest, ...grpc.CallOption) (*walletrpc.ImportPrivateKeyResponse, error)
	importPrivateKeyMutex       sync.RWMutex
	importPrivateKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.ImportPrivateKeyRequest
		arg3 []grpc.CallOption
	}
	importPrivateKeyReturns struct {
		result1 *walletrpc.ImportPrivateKeyResponse
		result2 error
	}
	importPrivateKeyReturnsOnCall map[int]struct {
		result1 *walletrpc.ImportPrivateKeyResponse
		result2 error
	}
	NetworkStub        func(context.Context, *walletrpc.NetworkRequest, ...grpc.CallOption) (*walletrpc.NetworkResponse, error)
	networkMutex       sync.RWMutex
	networkArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.NetworkRequest
		arg3 []grpc.CallOption
	}
	networkReturns struct {
		result1 *walletrpc.NetworkResponse
		result2 error
	}
	networkReturnsOnCall map[int]struct {
		result1 *walletrpc.NetworkResponse
		result2 error
	}
	NextAccountStub        func(context.Context, *walletrpc.NextAccountRequest, ...grpc.CallOption) (*walletrpc.NextAccountResponse, error)
	nextAccountMutex       sync.RWMutex
	nextAccountArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.NextAccountRequest
		arg3 []grpc.CallOption
	}
	nextAccountReturns struct {
		result1 *walletrpc.NextAccountResponse
		result2 error
	}
	nextAccountReturnsOnCall map[int]struct {
		result1 *walletrpc.NextAccountResponse
		result2 error
	}
	NextAddressStub        func(context.Context, *walletrpc.NextAddressRequest, ...grpc.CallOption) (*walletrpc.NextAddressResponse, error)
	nextAddressMutex       sync.RWMutex
	nextAddressArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.NextAddressRequest
		arg3 []grpc.CallOption
	}
	nextAddressReturns struct {
		result1 *walletrpc.NextAddressResponse
		result2 error
	}
	nextAddressReturnsOnCall map[int]struct {
		result1 *walletrpc.NextAddressResponse
		result2 error
	}
	PingStub        func(context.Context, *walletrpc.PingRequest, ...grpc.CallOption) (*walletrpc.PingResponse, error)
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.PingRequest
		arg3 []grpc.CallOption
	}
	pingReturns struct {
		result1 *walletrpc.PingResponse
		result2 error
	}
	pingReturnsOnCall map[int]struct {
		result1 *walletrpc.PingResponse
		result2 error
	}
	PostPaymentStub        func(context.Context, *walletrpc.PostPaymentRequest, ...grpc.CallOption) (*walletrpc.PostPaymentResponse, error)
	postPaymentMutex       sync.RWMutex
	postPaymentArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.PostPaymentRequest
		arg3 []grpc.CallOption
	}
	postPaymentReturns struct {
		result1 *walletrpc.PostPaymentResponse
		result2 error
	}
	postPaymentReturnsOnCall map[int]struct {
		result1 *walletrpc.PostPaymentResponse
		result2 error
	}
	PublishTransactionStub        func(context.Context, *walletrpc.PublishTransactionRequest, ...grpc.CallOption) (*walletrpc.PublishTransactionResponse, error)
	publishTransactionMutex       sync.RWMutex
	publishTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.PublishTransactionRequest
		arg3 []grpc.CallOption
	}
	publishTransactionReturns struct {
		result1 *walletrpc.PublishTransactionResponse
		result2 error
	}
	publishTransactionReturnsOnCall map[int]struct {
		result1 *walletrpc.PublishTransactionResponse
		result2 error
	}
	RenameAccountStub        func(context.Context, *walletrpc.RenameAccountRequest, ...grpc.CallOption) (*walletrpc.RenameAccountResponse, error)
	renameAccountMutex       sync.RWMutex
	renameAccountArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.RenameAccountRequest
		arg3 []grpc.CallOption
	}
	renameAccountReturns struct {
		result1 *walletrpc.RenameAccountResponse
		result2 error
	}
	renameAccountReturnsOnCall map[int]struct {
		result1 *walletrpc.RenameAccountResponse
		result2 error
	}
	RescanStub        func(context.Context, *walletrpc.RescanRequest, ...grpc.CallOption) (*walletrpc.RescanResponse, error)
	rescanMutex       sync.RWMutex
	rescanArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.RescanRequest
		arg3 []grpc.CallOption
	}
	rescanReturns struct {
		result1 *walletrpc.RescanResponse
		result2 error
	}
	rescanReturnsOnCall map[int]struct {
		result1 *walletrpc.RescanResponse
		result2 error
	}
	RescanNotificationsStub        func(context.Context, *walletrpc.RescanNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_RescanNotificationsClient, error)
	rescanNotificationsMutex       sync.RWMutex
	rescanNotificationsArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.RescanNotificationsRequest
		arg3 []grpc.CallOption
	}
	rescanNotificationsReturns struct {
		result1 walletrpc.WalletService_RescanNotificationsClient
		result2 error
	}
	rescanNotificationsReturnsOnCall map[int]struct {
		result1 walletrpc.WalletService_RescanNotificationsClient
		result2 error
	}
	SignTransactionStub        func(context.Context, *walletrpc.SignTransactionRequest, ...grpc.CallOption) (*walletrpc.SignTransactionResponse, error)
	signTransactionMutex       sync.RWMutex
	signTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.SignTransactionRequest
		arg3 []grpc.CallOption
	}
	signTransactionReturns struct {
		result1 *walletrpc.SignTransactionResponse
		result2 error
	}
	signTransactionReturnsOnCall map[int]struct {
		result1 *walletrpc.SignTransactionResponse
		result2 error
	}
	SpentnessNotificationsStub        func(context.Context, *walletrpc.SpentnessNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_SpentnessNotificationsClient, error)
	spentnessNotificationsMutex       sync.RWMutex
	spentnessNotificationsArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.SpentnessNotificationsRequest
		arg3 []grpc.CallOption
	}
	spentnessNotificationsReturns struct {
		result1 walletrpc.WalletService_SpentnessNotificationsClient
		result2 error
	}
	spentnessNotificationsReturnsOnCall map[int]struct {
		result1 walletrpc.WalletService_SpentnessNotificationsClient
		result2 error
	}
	SweepAccountStub        func(context.Context, *walletrpc.SweepAccountRequest, ...grpc.CallOption) (*walletrpc.SweepAccountResponse, error)
	sweepAccountMutex       sync.RWMutex
	sweepAccountArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.SweepAccountRequest
		arg3 []grpc.CallOption
	}
	sweepAccountReturns struct {
		result1 *walletrpc.SweepAccountResponse
		result2 error
	}
	sweepAccountReturnsOnCall map[int]struct {
		result1 *walletrpc.SweepAccountResponse
		result2 error
	}
	TransactionNotificationsStub        func(context.Context, *walletrpc.TransactionNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_TransactionNotificationsClient, error)
	transactionNotificationsMutex       sync.RWMutex
	transactionNotificationsArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.TransactionNotificationsRequest
		arg3 []grpc.CallOption
	}
	transactionNotificationsReturns struct {
		result1 walletrpc.WalletService_TransactionNotificationsClient
		result2 error
	}
	transactionNotificationsReturnsOnCall map[int]struct {
		result1 walletrpc.WalletService_TransactionNotificationsClient
		result2 error
	}
	ValidateAddressStub        func(context.Context, *walletrpc.ValidateAddressRequest, ...grpc.CallOption) (*walletrpc.ValidateAddressResponse, error)
	validateAddressMutex       sync.RWMutex
	validateAddressArgsForCall []struct {
		arg1 context.Context
		arg2 *walletrpc.ValidateAddressRequest
		arg3 []grpc.CallOption
	}
	validateAddressReturns struct {
		result1 *walletrpc.ValidateAddressResponse
		result2 error
	}
	validateAddressReturnsOnCall map[int]struct {
		result1 *walletrpc.ValidateAddressResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWalletServiceClient) AccountNotifications(arg1 context.Context, arg2 *walletrpc.AccountNotificationsRequest, arg3 ...grpc.CallOption) (walletrpc.WalletService_AccountNotificationsClient, error) {
	fake.accountNotificationsMutex.Lock()
	ret, specificReturn := fake.accountNotificationsReturnsOnCall[len(fake.accountNotificationsArgsForCall)]
	fake.accountNotificationsArgsForCall = append(fake.accountNotificationsArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.AccountNotificationsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("AccountNotifications", []interface{}{arg1, arg2, arg3})
	fake.accountNotificationsMutex.Unlock()
	if fake.AccountNotificationsStub != nil {
		return fake.AccountNotificationsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.accountNotificationsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) AccountNotificationsCallCount() int {
	fake.accountNotificationsMutex.RLock()
	defer fake.accountNotificationsMutex.RUnlock()
	return len(fake.accountNotificationsArgsForCall)
}

func (fake *FakeWalletServiceClient) AccountNotificationsCalls(stub func(context.Context, *walletrpc.AccountNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_AccountNotificationsClient, error)) {
	fake.accountNotificationsMutex.Lock()
	defer fake.accountNotificationsMutex.Unlock()
	fake.AccountNotificationsStub = stub
}

func (fake *FakeWalletServiceClient) AccountNotificationsArgsForCall(i int) (context.Context, *walletrpc.AccountNotificationsRequest, []grpc.CallOption) {
	fake.accountNotificationsMutex.RLock()
	defer fake.accountNotificationsMutex.RUnlock()
	argsForCall := fake.accountNotificationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) AccountNotificationsReturns(result1 walletrpc.WalletService_AccountNotificationsClient, result2 error) {
	fake.accountNotificationsMutex.Lock()
	defer fake.accountNotificationsMutex.Unlock()
	fake.AccountNotificationsStub = nil
	fake.accountNotificationsReturns = struct {
		result1 walletrpc.WalletService_AccountNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) AccountNotificationsReturnsOnCall(i int, result1 walletrpc.WalletService_AccountNotificationsClient, result2 error) {
	fake.accountNotificationsMutex.Lock()
	defer fake.accountNotificationsMutex.Unlock()
	fake.AccountNotificationsStub = nil
	if fake.accountNotificationsReturnsOnCall == nil {
		fake.accountNotificationsReturnsOnCall = make(map[int]struct {
			result1 walletrpc.WalletService_AccountNotificationsClient
			result2 error
		})
	}
	fake.accountNotificationsReturnsOnCall[i] = struct {
		result1 walletrpc.WalletService_AccountNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) AccountNumber(arg1 context.Context, arg2 *walletrpc.AccountNumberRequest, arg3 ...grpc.CallOption) (*walletrpc.AccountNumberResponse, error) {
	fake.accountNumberMutex.Lock()
	ret, specificReturn := fake.accountNumberReturnsOnCall[len(fake.accountNumberArgsForCall)]
	fake.accountNumberArgsForCall = append(fake.accountNumberArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.AccountNumberRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("AccountNumber", []interface{}{arg1, arg2, arg3})
	fake.accountNumberMutex.Unlock()
	if fake.AccountNumberStub != nil {
		return fake.AccountNumberStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.accountNumberReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) AccountNumberCallCount() int {
	fake.accountNumberMutex.RLock()
	defer fake.accountNumberMutex.RUnlock()
	return len(fake.accountNumberArgsForCall)
}

func (fake *FakeWalletServiceClient) AccountNumberCalls(stub func(context.Context, *walletrpc.AccountNumberRequest, ...grpc.CallOption) (*walletrpc.AccountNumberResponse, error)) {
	fake.accountNumberMutex.Lock()
	defer fake.accountNumberMutex.Unlock()
	fake.AccountNumberStub = stub
}

func (fake *FakeWalletServiceClient) AccountNumberArgsForCall(i int) (context.Context, *walletrpc.AccountNumberRequest, []grpc.CallOption) {
	fake.accountNumberMutex.RLock()
	defer fake.accountNumberMutex.RUnlock()
	argsForCall := fake.accountNumberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) AccountNumberReturns(result1 *walletrpc.AccountNumberResponse, result2 error) {
	fake.accountNumberMutex.Lock()
	defer fake.accountNumberMutex.Unlock()
	fake.AccountNumberStub = nil
	fake.accountNumberReturns = struct {
		result1 *walletrpc.AccountNumberResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) AccountNumberReturnsOnCall(i int, result1 *walletrpc.AccountNumberResponse, result2 error) {
	fake.accountNumberMutex.Lock()
	defer fake.accountNumberMutex.Unlock()
	fake.AccountNumberStub = nil
	if fake.accountNumberReturnsOnCall == nil {
		fake.accountNumberReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.AccountNumberResponse
			result2 error
		})
	}
	fake.accountNumberReturnsOnCall[i] = struct {
		result1 *walletrpc.AccountNumberResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) Accounts(arg1 context.Context, arg2 *walletrpc.AccountsRequest, arg3 ...grpc.CallOption) (*walletrpc.AccountsResponse, error) {
	fake.accountsMutex.Lock()
	ret, specificReturn := fake.accountsReturnsOnCall[len(fake.accountsArgsForCall)]
	fake.accountsArgsForCall = append(fake.accountsArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.AccountsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Accounts", []interface{}{arg1, arg2, arg3})
	fake.accountsMutex.Unlock()
	if fake.AccountsStub != nil {
		return fake.AccountsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.accountsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) AccountsCallCount() int {
	fake.accountsMutex.RLock()
	defer fake.accountsMutex.RUnlock()
	return len(fake.accountsArgsForCall)
}

func (fake *FakeWalletServiceClient) AccountsCalls(stub func(context.Context, *walletrpc.AccountsRequest, ...grpc.CallOption) (*walletrpc.AccountsResponse, error)) {
	fake.accountsMutex.Lock()
	defer fake.accountsMutex.Unlock()
	fake.AccountsStub = stub
}

func (fake *FakeWalletServiceClient) AccountsArgsForCall(i int) (context.Context, *walletrpc.AccountsRequest, []grpc.CallOption) {
	fake.accountsMutex.RLock()
	defer fake.accountsMutex.RUnlock()
	argsForCall := fake.accountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) AccountsReturns(result1 *walletrpc.AccountsResponse, result2 error) {
	fake.accountsMutex.Lock()
	defer fake.accountsMutex.Unlock()
	fake.AccountsStub = nil
	fake.accountsReturns = struct {
		result1 *walletrpc.AccountsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) AccountsReturnsOnCall(i int, result1 *walletrpc.AccountsResponse, result2 error) {
	fake.accountsMutex.Lock()
	defer fake.accountsMutex.Unlock()
	fake.AccountsStub = nil
	if fake.accountsReturnsOnCall == nil {
		fake.accountsReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.AccountsResponse
			result2 error
		})
	}
	fake.accountsReturnsOnCall[i] = struct {
		result1 *walletrpc.AccountsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) Balance(arg1 context.Context, arg2 *walletrpc.BalanceRequest, arg3 ...grpc.CallOption) (*walletrpc.BalanceResponse, error) {
	fake.balanceMutex.Lock()
	ret, specificReturn := fake.balanceReturnsOnCall[len(fake.balanceArgsForCall)]
	fake.balanceArgsForCall = append(fake.balanceArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.BalanceRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Balance", []interface{}{arg1, arg2, arg3})
	fake.balanceMutex.Unlock()
	if fake.BalanceStub != nil {
		return fake.BalanceStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.balanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) BalanceCallCount() int {
	fake.balanceMutex.RLock()
	defer fake.balanceMutex.RUnlock()
	return len(fake.balanceArgsForCall)
}

func (fake *FakeWalletServiceClient) BalanceCalls(stub func(context.Context, *walletrpc.BalanceRequest, ...grpc.CallOption) (*walletrpc.BalanceResponse, error)) {
	fake.balanceMutex.Lock()
	defer fake.balanceMutex.Unlock()
	fake.BalanceStub = stub
}

func (fake *FakeWalletServiceClient) BalanceArgsForCall(i int) (context.Context, *walletrpc.BalanceRequest, []grpc.CallOption) {
	fake.balanceMutex.RLock()
	defer fake.balanceMutex.RUnlock()
	argsForCall := fake.balanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) BalanceReturns(result1 *walletrpc.BalanceResponse, result2 error) {
	fake.balanceMutex.Lock()
	defer fake.balanceMutex.Unlock()
	fake.BalanceStub = nil
	fake.balanceReturns = struct {
		result1 *walletrpc.BalanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) BalanceReturnsOnCall(i int, result1 *walletrpc.BalanceResponse, result2 error) {
	fake.balanceMutex.Lock()
	defer fake.balanceMutex.Unlock()
	fake.BalanceStub = nil
	if fake.balanceReturnsOnCall == nil {
		fake.balanceReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.BalanceResponse
			result2 error
		})
	}
	fake.balanceReturnsOnCall[i] = struct {
		result1 *walletrpc.BalanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) ChangePassphrase(arg1 context.Context, arg2 *walletrpc.ChangePassphraseRequest, arg3 ...grpc.CallOption) (*walletrpc.ChangePassphraseResponse, error) {
	fake.changePassphraseMutex.Lock()
	ret, specificReturn := fake.changePassphraseReturnsOnCall[len(fake.changePassphraseArgsForCall)]
	fake.changePassphraseArgsForCall = append(fake.changePassphraseArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.ChangePassphraseRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("ChangePassphrase", []interface{}{arg1, arg2, arg3})
	fake.changePassphraseMutex.Unlock()
	if fake.ChangePassphraseStub != nil {
		return fake.ChangePassphraseStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.changePassphraseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) ChangePassphraseCallCount() int {
	fake.changePassphraseMutex.RLock()
	defer fake.changePassphraseMutex.RUnlock()
	return len(fake.changePassphraseArgsForCall)
}

func (fake *FakeWalletServiceClient) ChangePassphraseCalls(stub func(context.Context, *walletrpc.ChangePassphraseRequest, ...grpc.CallOption) (*walletrpc.ChangePassphraseResponse, error)) {
	fake.changePassphraseMutex.Lock()
	defer fake.changePassphraseMutex.Unlock()
	fake.ChangePassphraseStub = stub
}

func (fake *FakeWalletServiceClient) ChangePassphraseArgsForCall(i int) (context.Context, *walletrpc.ChangePassphraseRequest, []grpc.CallOption) {
	fake.changePassphraseMutex.RLock()
	defer fake.changePassphraseMutex.RUnlock()
	argsForCall := fake.changePassphraseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) ChangePassphraseReturns(result1 *walletrpc.ChangePassphraseResponse, result2 error) {
	fake.changePassphraseMutex.Lock()
	defer fake.changePassphraseMutex.Unlock()
	fake.ChangePassphraseStub = nil
	fake.changePassphraseReturns = struct {
		result1 *walletrpc.ChangePassphraseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) ChangePassphraseReturnsOnCall(i int, result1 *walletrpc.ChangePassphraseResponse, result2 error) {
	fake.changePassphraseMutex.Lock()
	defer fake.changePassphraseMutex.Unlock()
	fake.ChangePassphraseStub = nil
	if fake.changePassphraseReturnsOnCall == nil {
		fake.changePassphraseReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.ChangePassphraseResponse
			result2 error
		})
	}
	fake.changePassphraseReturnsOnCall[i] = struct {
		result1 *walletrpc.ChangePassphraseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) CreateTransaction(arg1 context.Context, arg2 *walletrpc.CreateTransactionRequest, arg3 ...grpc.CallOption) (*walletrpc.CreateTransactionResponse, error) {
	fake.createTransactionMutex.Lock()
	ret, specificReturn := fake.createTransactionReturnsOnCall[len(fake.createTransactionArgsForCall)]
	fake.createTransactionArgsForCall = append(fake.createTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.CreateTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateTransaction", []interface{}{arg1, arg2, arg3})
	fake.createTransactionMutex.Unlock()
	if fake.CreateTransactionStub != nil {
		return fake.CreateTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) CreateTransactionCallCount() int {
	fake.createTransactionMutex.RLock()
	defer fake.createTransactionMutex.RUnlock()
	return len(fake.createTransactionArgsForCall)
}

func (fake *FakeWalletServiceClient) CreateTransactionCalls(stub func(context.Context, *walletrpc.CreateTransactionRequest, ...grpc.CallOption) (*walletrpc.CreateTransactionResponse, error)) {
	fake.createTransactionMutex.Lock()
	defer fake.createTransactionMutex.Unlock()
	fake.CreateTransactionStub = stub
}

func (fake *FakeWalletServiceClient) CreateTransactionArgsForCall(i int) (context.Context, *walletrpc.CreateTransactionRequest, []grpc.CallOption) {
	fake.createTransactionMutex.RLock()
	defer fake.createTransactionMutex.RUnlock()
	argsForCall := fake.createTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) CreateTransactionReturns(result1 *walletrpc.CreateTransactionResponse, result2 error) {
	fake.createTransactionMutex.Lock()
	defer fake.createTransactionMutex.Unlock()
	fake.CreateTransactionStub = nil
	fake.createTransactionReturns = struct {
		result1 *walletrpc.CreateTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) CreateTransactionReturnsOnCall(i int, result1 *walletrpc.CreateTransactionResponse, result2 error) {
	fake.createTransactionMutex.Lock()
	defer fake.createTransactionMutex.Unlock()
	fake.CreateTransactionStub = nil
	if fake.createTransactionReturnsOnCall == nil {
		fake.createTransactionReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.CreateTransactionResponse
			result2 error
		})
	}
	fake.createTransactionReturnsOnCall[i] = struct {
		result1 *walletrpc.CreateTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) CurrentAddress(arg1 context.Context, arg2 *walletrpc.CurrentAddressRequest, arg3 ...grpc.CallOption) (*walletrpc.CurrentAddressResponse, error) {
	fake.currentAddressMutex.Lock()
	ret, specificReturn := fake.currentAddressReturnsOnCall[len(fake.currentAddressArgsForCall)]
	fake.currentAddressArgsForCall = append(fake.currentAddressArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.CurrentAddressRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("CurrentAddress", []interface{}{arg1, arg2, arg3})
	fake.currentAddressMutex.Unlock()
	if fake.CurrentAddressStub != nil {
		return fake.CurrentAddressStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentAddressReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) CurrentAddressCallCount() int {
	fake.currentAddressMutex.RLock()
	defer fake.currentAddressMutex.RUnlock()
	return len(fake.currentAddressArgsForCall)
}

func (fake *FakeWalletServiceClient) CurrentAddressCalls(stub func(context.Context, *walletrpc.CurrentAddressRequest, ...grpc.CallOption) (*walletrpc.CurrentAddressResponse, error)) {
	fake.currentAddressMutex.Lock()
	defer fake.currentAddressMutex.Unlock()
	fake.CurrentAddressStub = stub
}

func (fake *FakeWalletServiceClient) CurrentAddressArgsForCall(i int) (context.Context, *walletrpc.CurrentAddressRequest, []grpc.CallOption) {
	fake.currentAddressMutex.RLock()
	defer fake.currentAddressMutex.RUnlock()
	argsForCall := fake.currentAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) CurrentAddressReturns(result1 *walletrpc.CurrentAddressResponse, result2 error) {
	fake.currentAddressMutex.Lock()
	defer fake.currentAddressMutex.Unlock()
	fake.CurrentAddressStub = nil
	fake.currentAddressReturns = struct {
		result1 *walletrpc.CurrentAddressResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) CurrentAddressReturnsOnCall(i int, result1 *walletrpc.CurrentAddressResponse, result2 error) {
	fake.currentAddressMutex.Lock()
	defer fake.currentAddressMutex.Unlock()
	fake.CurrentAddressStub = nil
	if fake.currentAddressReturnsOnCall == nil {
		fake.currentAddressReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.CurrentAddressResponse
			result2 error
		})
	}
	fake.currentAddressReturnsOnCall[i] = struct {
		result1 *walletrpc.CurrentAddressResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) DownloadPaymentRequest(arg1 context.Context, arg2 *walletrpc.DownloadPaymentRequestRequest, arg3 ...grpc.CallOption) (*walletrpc.DownloadPaymentRequestResponse, error) {
	fake.downloadPaymentRequestMutex.Lock()
	ret, specificReturn := fake.downloadPaymentRequestReturnsOnCall[len(fake.downloadPaymentRequestArgsForCall)]
	fake.downloadPaymentRequestArgsForCall = append(fake.downloadPaymentRequestArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.DownloadPaymentRequestRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("DownloadPaymentRequest", []interface{}{arg1, arg2, arg3})
	fake.downloadPaymentRequestMutex.Unlock()
	if fake.DownloadPaymentRequestStub != nil {
		return fake.DownloadPaymentRequestStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.downloadPaymentRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) DownloadPaymentRequestCallCount() int {
	fake.downloadPaymentRequestMutex.RLock()
	defer fake.downloadPaymentRequestMutex.RUnlock()
	return len(fake.downloadPaymentRequestArgsForCall)
}

func (fake *FakeWalletServiceClient) DownloadPaymentRequestCalls(stub func(context.Context, *walletrpc.DownloadPaymentRequestRequest, ...grpc.CallOption) (*walletrpc.DownloadPaymentRequestResponse, error)) {
	fake.downloadPaymentRequestMutex.Lock()
	defer fake.downloadPaymentRequestMutex.Unlock()
	fake.DownloadPaymentRequestStub = stub
}

func (fake *FakeWalletServiceClient) DownloadPaymentRequestArgsForCall(i int) (context.Context, *walletrpc.DownloadPaymentRequestRequest, []grpc.CallOption) {
	fake.downloadPaymentRequestMutex.RLock()
	defer fake.downloadPaymentRequestMutex.RUnlock()
	argsForCall := fake.downloadPaymentRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) DownloadPaymentRequestReturns(result1 *walletrpc.DownloadPaymentRequestResponse, result2 error) {
	fake.downloadPaymentRequestMutex.Lock()
	defer fake.downloadPaymentRequestMutex.Unlock()
	fake.DownloadPaymentRequestStub = nil
	fake.downloadPaymentRequestReturns = struct {
		result1 *walletrpc.DownloadPaymentRequestResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) DownloadPaymentRequestReturnsOnCall(i int, result1 *walletrpc.DownloadPaymentRequestResponse, result2 error) {
	fake.downloadPaymentRequestMutex.Lock()
	defer fake.downloadPaymentRequestMutex.Unlock()
	fake.DownloadPaymentRequestStub = nil
	if fake.downloadPaymentRequestReturnsOnCall == nil {
		fake.downloadPaymentRequestReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.DownloadPaymentRequestResponse
			result2 error
		})
	}
	fake.downloadPaymentRequestReturnsOnCall[i] = struct {
		result1 *walletrpc.DownloadPaymentRequestResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) FundTransaction(arg1 context.Context, arg2 *walletrpc.FundTransactionRequest, arg3 ...grpc.CallOption) (*walletrpc.FundTransactionResponse, error) {
	fake.fundTransactionMutex.Lock()
	ret, specificReturn := fake.fundTransactionReturnsOnCall[len(fake.fundTransactionArgsForCall)]
	fake.fundTransactionArgsForCall = append(fake.fundTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.FundTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("FundTransaction", []interface{}{arg1, arg2, arg3})
	fake.fundTransactionMutex.Unlock()
	if fake.FundTransactionStub != nil {
		return fake.FundTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.fundTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) FundTransactionCallCount() int {
	fake.fundTransactionMutex.RLock()
	defer fake.fundTransactionMutex.RUnlock()
	return len(fake.fundTransactionArgsForCall)
}

func (fake *FakeWalletServiceClient) FundTransactionCalls(stub func(context.Context, *walletrpc.FundTransactionRequest, ...grpc.CallOption) (*walletrpc.FundTransactionResponse, error)) {
	fake.fundTransactionMutex.Lock()
	defer fake.fundTransactionMutex.Unlock()
	fake.FundTransactionStub = stub
}

func (fake *FakeWalletServiceClient) FundTransactionArgsForCall(i int) (context.Context, *walletrpc.FundTransactionRequest, []grpc.CallOption) {
	fake.fundTransactionMutex.RLock()
	defer fake.fundTransactionMutex.RUnlock()
	argsForCall := fake.fundTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) FundTransactionReturns(result1 *walletrpc.FundTransactionResponse, result2 error) {
	fake.fundTransactionMutex.Lock()
	defer fake.fundTransactionMutex.Unlock()
	fake.FundTransactionStub = nil
	fake.fundTransactionReturns = struct {
		result1 *walletrpc.FundTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) FundTransactionReturnsOnCall(i int, result1 *walletrpc.FundTransactionResponse, result2 error) {
	fake.fundTransactionMutex.Lock()
	defer fake.fundTransactionMutex.Unlock()
	fake.FundTransactionStub = nil
	if fake.fundTransactionReturnsOnCall == nil {
		fake.fundTransactionReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.FundTransactionResponse
			result2 error
		})
	}
	fake.fundTransactionReturnsOnCall[i] = struct {
		result1 *walletrpc.FundTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) GetTransactions(arg1 context.Context, arg2 *walletrpc.GetTransactionsRequest, arg3 ...grpc.CallOption) (*walletrpc.GetTransactionsResponse, error) {
	fake.getTransactionsMutex.Lock()
	ret, specificReturn := fake.getTransactionsReturnsOnCall[len(fake.getTransactionsArgsForCall)]
	fake.getTransactionsArgsForCall = append(fake.getTransactionsArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.GetTransactionsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetTransactions", []interface{}{arg1, arg2, arg3})
	fake.getTransactionsMutex.Unlock()
	if fake.GetTransactionsStub != nil {
		return fake.GetTransactionsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTransactionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) GetTransactionsCallCount() int {
	fake.getTransactionsMutex.RLock()
	defer fake.getTransactionsMutex.RUnlock()
	return len(fake.getTransactionsArgsForCall)
}

func (fake *FakeWalletServiceClient) GetTransactionsCalls(stub func(context.Context, *walletrpc.GetTransactionsRequest, ...grpc.CallOption) (*walletrpc.GetTransactionsResponse, error)) {
	fake.getTransactionsMutex.Lock()
	defer fake.getTransactionsMutex.Unlock()
	fake.GetTransactionsStub = stub
}

func (fake *FakeWalletServiceClient) GetTransactionsArgsForCall(i int) (context.Context, *walletrpc.GetTransactionsRequest, []grpc.CallOption) {
	fake.getTransactionsMutex.RLock()
	defer fake.getTransactionsMutex.RUnlock()
	argsForCall := fake.getTransactionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) GetTransactionsReturns(result1 *walletrpc.GetTransactionsResponse, result2 error) {
	fake.getTransactionsMutex.Lock()
	defer fake.getTransactionsMutex.Unlock()
	fake.GetTransactionsStub = nil
	fake.getTransactionsReturns = struct {
		result1 *walletrpc.GetTransactionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) GetTransactionsReturnsOnCall(i int, result1 *walletrpc.GetTransactionsResponse, result2 error) {
	fake.getTransactionsMutex.Lock()
	defer fake.getTransactionsMutex.Unlock()
	fake.GetTransactionsStub = nil
	if fake.getTransactionsReturnsOnCall == nil {
		fake.getTransactionsReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.GetTransactionsResponse
			result2 error
		})
	}
	fake.getTransactionsReturnsOnCall[i] = struct {
		result1 *walletrpc.GetTransactionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) ImportPrivateKey(arg1 context.Context, arg2 *walletrpc.ImportPrivateKeyRequest, arg3 ...grpc.CallOption) (*walletrpc.ImportPrivateKeyResponse, error) {
	fake.importPrivateKeyMutex.Lock()
	ret, specificReturn := fake.importPrivateKeyReturnsOnCall[len(fake.importPrivateKeyArgsForCall)]
	fake.importPrivateKeyArgsForCall = append(fake.importPrivateKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.ImportPrivateKeyRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImportPrivateKey", []interface{}{arg1, arg2, arg3})
	fake.importPrivateKeyMutex.Unlock()
	if fake.ImportPrivateKeyStub != nil {
		return fake.ImportPrivateKeyStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.importPrivateKeyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) ImportPrivateKeyCallCount() int {
	fake.importPrivateKeyMutex.RLock()
	defer fake.importPrivateKeyMutex.RUnlock()
	return len(fake.importPrivateKeyArgsForCall)
}

func (fake *FakeWalletServiceClient) ImportPrivateKeyCalls(stub func(context.Context, *walletrpc.ImportPrivateKeyRequest, ...grpc.CallOption) (*walletrpc.ImportPrivateKeyResponse, error)) {
	fake.importPrivateKeyMutex.Lock()
	defer fake.importPrivateKeyMutex.Unlock()
	fake.ImportPrivateKeyStub = stub
}

func (fake *FakeWalletServiceClient) ImportPrivateKeyArgsForCall(i int) (context.Context, *walletrpc.ImportPrivateKeyRequest, []grpc.CallOption) {
	fake.importPrivateKeyMutex.RLock()
	defer fake.importPrivateKeyMutex.RUnlock()
	argsForCall := fake.importPrivateKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) ImportPrivateKeyReturns(result1 *walletrpc.ImportPrivateKeyResponse, result2 error) {
	fake.importPrivateKeyMutex.Lock()
	defer fake.importPrivateKeyMutex.Unlock()
	fake.ImportPrivateKeyStub = nil
	fake.importPrivateKeyReturns = struct {
		result1 *walletrpc.ImportPrivateKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) ImportPrivateKeyReturnsOnCall(i int, result1 *walletrpc.ImportPrivateKeyResponse, result2 error) {
	fake.importPrivateKeyMutex.Lock()
	defer fake.importPrivateKeyMutex.Unlock()
	fake.ImportPrivateKeyStub = nil
	if fake.importPrivateKeyReturnsOnCall == nil {
		fake.importPrivateKeyReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.ImportPrivateKeyResponse
			result2 error
		})
	}
	fake.importPrivateKeyReturnsOnCall[i] = struct {
		result1 *walletrpc.ImportPrivateKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) Network(arg1 context.Context, arg2 *walletrpc.NetworkRequest, arg3 ...grpc.CallOption) (*walletrpc.NetworkResponse, error) {
	fake.networkMutex.Lock()
	ret, specificReturn := fake.networkReturnsOnCall[len(fake.networkArgsForCall)]
	fake.networkArgsForCall = append(fake.networkArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.NetworkRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Network", []interface{}{arg1, arg2, arg3})
	fake.networkMutex.Unlock()
	if fake.NetworkStub != nil {
		return fake.NetworkStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.networkReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) NetworkCallCount() int {
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	return len(fake.networkArgsForCall)
}

func (fake *FakeWalletServiceClient) NetworkCalls(stub func(context.Context, *walletrpc.NetworkRequest, ...grpc.CallOption) (*walletrpc.NetworkResponse, error)) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = stub
}

func (fake *FakeWalletServiceClient) NetworkArgsForCall(i int) (context.Context, *walletrpc.NetworkRequest, []grpc.CallOption) {
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	argsForCall := fake.networkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) NetworkReturns(result1 *walletrpc.NetworkResponse, result2 error) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	fake.networkReturns = struct {
		result1 *walletrpc.NetworkResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) NetworkReturnsOnCall(i int, result1 *walletrpc.NetworkResponse, result2 error) {
	fake.networkMutex.Lock()
	defer fake.networkMutex.Unlock()
	fake.NetworkStub = nil
	if fake.networkReturnsOnCall == nil {
		fake.networkReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.NetworkResponse
			result2 error
		})
	}
	fake.networkReturnsOnCall[i] = struct {
		result1 *walletrpc.NetworkResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) NextAccount(arg1 context.Context, arg2 *walletrpc.NextAccountRequest, arg3 ...grpc.CallOption) (*walletrpc.NextAccountResponse, error) {
	fake.nextAccountMutex.Lock()
	ret, specificReturn := fake.nextAccountReturnsOnCall[len(fake.nextAccountArgsForCall)]
	fake.nextAccountArgsForCall = append(fake.nextAccountArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.NextAccountRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("NextAccount", []interface{}{arg1, arg2, arg3})
	fake.nextAccountMutex.Unlock()
	if fake.NextAccountStub != nil {
		return fake.NextAccountStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.nextAccountReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) NextAccountCallCount() int {
	fake.nextAccountMutex.RLock()
	defer fake.nextAccountMutex.RUnlock()
	return len(fake.nextAccountArgsForCall)
}

func (fake *FakeWalletServiceClient) NextAccountCalls(stub func(context.Context, *walletrpc.NextAccountRequest, ...grpc.CallOption) (*walletrpc.NextAccountResponse, error)) {
	fake.nextAccountMutex.Lock()
	defer fake.nextAccountMutex.Unlock()
	fake.NextAccountStub = stub
}

func (fake *FakeWalletServiceClient) NextAccountArgsForCall(i int) (context.Context, *walletrpc.NextAccountRequest, []grpc.CallOption) {
	fake.nextAccountMutex.RLock()
	defer fake.nextAccountMutex.RUnlock()
	argsForCall := fake.nextAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) NextAccountReturns(result1 *walletrpc.NextAccountResponse, result2 error) {
	fake.nextAccountMutex.Lock()
	defer fake.nextAccountMutex.Unlock()
	fake.NextAccountStub = nil
	fake.nextAccountReturns = struct {
		result1 *walletrpc.NextAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) NextAccountReturnsOnCall(i int, result1 *walletrpc.NextAccountResponse, result2 error) {
	fake.nextAccountMutex.Lock()
	defer fake.nextAccountMutex.Unlock()
	fake.NextAccountStub = nil
	if fake.nextAccountReturnsOnCall == nil {
		fake.nextAccountReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.NextAccountResponse
			result2 error
		})
	}
	fake.nextAccountReturnsOnCall[i] = struct {
		result1 *walletrpc.NextAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) NextAddress(arg1 context.Context, arg2 *walletrpc.NextAddressRequest, arg3 ...grpc.CallOption) (*walletrpc.NextAddressResponse, error) {
	fake.nextAddressMutex.Lock()
	ret, specificReturn := fake.nextAddressReturnsOnCall[len(fake.nextAddressArgsForCall)]
	fake.nextAddressArgsForCall = append(fake.nextAddressArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.NextAddressRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("NextAddress", []interface{}{arg1, arg2, arg3})
	fake.nextAddressMutex.Unlock()
	if fake.NextAddressStub != nil {
		return fake.NextAddressStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.nextAddressReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) NextAddressCallCount() int {
	fake.nextAddressMutex.RLock()
	defer fake.nextAddressMutex.RUnlock()
	return len(fake.nextAddressArgsForCall)
}

func (fake *FakeWalletServiceClient) NextAddressCalls(stub func(context.Context, *walletrpc.NextAddressRequest, ...grpc.CallOption) (*walletrpc.NextAddressResponse, error)) {
	fake.nextAddressMutex.Lock()
	defer fake.nextAddressMutex.Unlock()
	fake.NextAddressStub = stub
}

func (fake *FakeWalletServiceClient) NextAddressArgsForCall(i int) (context.Context, *walletrpc.NextAddressRequest, []grpc.CallOption) {
	fake.nextAddressMutex.RLock()
	defer fake.nextAddressMutex.RUnlock()
	argsForCall := fake.nextAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) NextAddressReturns(result1 *walletrpc.NextAddressResponse, result2 error) {
	fake.nextAddressMutex.Lock()
	defer fake.nextAddressMutex.Unlock()
	fake.NextAddressStub = nil
	fake.nextAddressReturns = struct {
		result1 *walletrpc.NextAddressResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) NextAddressReturnsOnCall(i int, result1 *walletrpc.NextAddressResponse, result2 error) {
	fake.nextAddressMutex.Lock()
	defer fake.nextAddressMutex.Unlock()
	fake.NextAddressStub = nil
	if fake.nextAddressReturnsOnCall == nil {
		fake.nextAddressReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.NextAddressResponse
			result2 error
		})
	}
	fake.nextAddressReturnsOnCall[i] = struct {
		result1 *walletrpc.NextAddressResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) Ping(arg1 context.Context, arg2 *walletrpc.PingRequest, arg3 ...grpc.CallOption) (*walletrpc.PingResponse, error) {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.PingRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Ping", []interface{}{arg1, arg2, arg3})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeWalletServiceClient) PingCalls(stub func(context.Context, *walletrpc.PingRequest, ...grpc.CallOption) (*walletrpc.PingResponse, error)) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeWalletServiceClient) PingArgsForCall(i int) (context.Context, *walletrpc.PingRequest, []grpc.CallOption) {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) PingReturns(result1 *walletrpc.PingResponse, result2 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 *walletrpc.PingResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) PingReturnsOnCall(i int, result1 *walletrpc.PingResponse, result2 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.PingResponse
			result2 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 *walletrpc.PingResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) PostPayment(arg1 context.Context, arg2 *walletrpc.PostPaymentRequest, arg3 ...grpc.CallOption) (*walletrpc.PostPaymentResponse, error) {
	fake.postPaymentMutex.Lock()
	ret, specificReturn := fake.postPaymentReturnsOnCall[len(fake.postPaymentArgsForCall)]
	fake.postPaymentArgsForCall = append(fake.postPaymentArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.PostPaymentRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("PostPayment", []interface{}{arg1, arg2, arg3})
	fake.postPaymentMutex.Unlock()
	if fake.PostPaymentStub != nil {
		return fake.PostPaymentStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postPaymentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) PostPaymentCallCount() int {
	fake.postPaymentMutex.RLock()
	defer fake.postPaymentMutex.RUnlock()
	return len(fake.postPaymentArgsForCall)
}

func (fake *FakeWalletServiceClient) PostPaymentCalls(stub func(context.Context, *walletrpc.PostPaymentRequest, ...grpc.CallOption) (*walletrpc.PostPaymentResponse, error)) {
	fake.postPaymentMutex.Lock()
	defer fake.postPaymentMutex.Unlock()
	fake.PostPaymentStub = stub
}

func (fake *FakeWalletServiceClient) PostPaymentArgsForCall(i int) (context.Context, *walletrpc.PostPaymentRequest, []grpc.CallOption) {
	fake.postPaymentMutex.RLock()
	defer fake.postPaymentMutex.RUnlock()
	argsForCall := fake.postPaymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) PostPaymentReturns(result1 *walletrpc.PostPaymentResponse, result2 error) {
	fake.postPaymentMutex.Lock()
	defer fake.postPaymentMutex.Unlock()
	fake.PostPaymentStub = nil
	fake.postPaymentReturns = struct {
		result1 *walletrpc.PostPaymentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) PostPaymentReturnsOnCall(i int, result1 *walletrpc.PostPaymentResponse, result2 error) {
	fake.postPaymentMutex.Lock()
	defer fake.postPaymentMutex.Unlock()
	fake.PostPaymentStub = nil
	if fake.postPaymentReturnsOnCall == nil {
		fake.postPaymentReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.PostPaymentResponse
			result2 error
		})
	}
	fake.postPaymentReturnsOnCall[i] = struct {
		result1 *walletrpc.PostPaymentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) PublishTransaction(arg1 context.Context, arg2 *walletrpc.PublishTransactionRequest, arg3 ...grpc.CallOption) (*walletrpc.PublishTransactionResponse, error) {
	fake.publishTransactionMutex.Lock()
	ret, specificReturn := fake.publishTransactionReturnsOnCall[len(fake.publishTransactionArgsForCall)]
	fake.publishTransactionArgsForCall = append(fake.publishTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.PublishTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("PublishTransaction", []interface{}{arg1, arg2, arg3})
	fake.publishTransactionMutex.Unlock()
	if fake.PublishTransactionStub != nil {
		return fake.PublishTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.publishTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) PublishTransactionCallCount() int {
	fake.publishTransactionMutex.RLock()
	defer fake.publishTransactionMutex.RUnlock()
	return len(fake.publishTransactionArgsForCall)
}

func (fake *FakeWalletServiceClient) PublishTransactionCalls(stub func(context.Context, *walletrpc.PublishTransactionRequest, ...grpc.CallOption) (*walletrpc.PublishTransactionResponse, error)) {
	fake.publishTransactionMutex.Lock()
	defer fake.publishTransactionMutex.Unlock()
	fake.PublishTransactionStub = stub
}

func (fake *FakeWalletServiceClient) PublishTransactionArgsForCall(i int) (context.Context, *walletrpc.PublishTransactionRequest, []grpc.CallOption) {
	fake.publishTransactionMutex.RLock()
	defer fake.publishTransactionMutex.RUnlock()
	argsForCall := fake.publishTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) PublishTransactionReturns(result1 *walletrpc.PublishTransactionResponse, result2 error) {
	fake.publishTransactionMutex.Lock()
	defer fake.publishTransactionMutex.Unlock()
	fake.PublishTransactionStub = nil
	fake.publishTransactionReturns = struct {
		result1 *walletrpc.PublishTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) PublishTransactionReturnsOnCall(i int, result1 *walletrpc.PublishTransactionResponse, result2 error) {
	fake.publishTransactionMutex.Lock()
	defer fake.publishTransactionMutex.Unlock()
	fake.PublishTransactionStub = nil
	if fake.publishTransactionReturnsOnCall == nil {
		fake.publishTransactionReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.PublishTransactionResponse
			result2 error
		})
	}
	fake.publishTransactionReturnsOnCall[i] = struct {
		result1 *walletrpc.PublishTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) RenameAccount(arg1 context.Context, arg2 *walletrpc.RenameAccountRequest, arg3 ...grpc.CallOption) (*walletrpc.RenameAccountResponse, error) {
	fake.renameAccountMutex.Lock()
	ret, specificReturn := fake.renameAccountReturnsOnCall[len(fake.renameAccountArgsForCall)]
	fake.renameAccountArgsForCall = append(fake.renameAccountArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.RenameAccountRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("RenameAccount", []interface{}{arg1, arg2, arg3})
	fake.renameAccountMutex.Unlock()
	if fake.RenameAccountStub != nil {
		return fake.RenameAccountStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.renameAccountReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) RenameAccountCallCount() int {
	fake.renameAccountMutex.RLock()
	defer fake.renameAccountMutex.RUnlock()
	return len(fake.renameAccountArgsForCall)
}

func (fake *FakeWalletServiceClient) RenameAccountCalls(stub func(context.Context, *walletrpc.RenameAccountRequest, ...grpc.CallOption) (*walletrpc.RenameAccountResponse, error)) {
	fake.renameAccountMutex.Lock()
	defer fake.renameAccountMutex.Unlock()
	fake.RenameAccountStub = stub
}

func (fake *FakeWalletServiceClient) RenameAccountArgsForCall(i int) (context.Context, *walletrpc.RenameAccountRequest, []grpc.CallOption) {
	fake.renameAccountMutex.RLock()
	defer fake.renameAccountMutex.RUnlock()
	argsForCall := fake.renameAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) RenameAccountReturns(result1 *walletrpc.RenameAccountResponse, result2 error) {
	fake.renameAccountMutex.Lock()
	defer fake.renameAccountMutex.Unlock()
	fake.RenameAccountStub = nil
	fake.renameAccountReturns = struct {
		result1 *walletrpc.RenameAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) RenameAccountReturnsOnCall(i int, result1 *walletrpc.RenameAccountResponse, result2 error) {
	fake.renameAccountMutex.Lock()
	defer fake.renameAccountMutex.Unlock()
	fake.RenameAccountStub = nil
	if fake.renameAccountReturnsOnCall == nil {
		fake.renameAccountReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.RenameAccountResponse
			result2 error
		})
	}
	fake.renameAccountReturnsOnCall[i] = struct {
		result1 *walletrpc.RenameAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) Rescan(arg1 context.Context, arg2 *walletrpc.RescanRequest, arg3 ...grpc.CallOption) (*walletrpc.RescanResponse, error) {
	fake.rescanMutex.Lock()
	ret, specificReturn := fake.rescanReturnsOnCall[len(fake.rescanArgsForCall)]
	fake.rescanArgsForCall = append(fake.rescanArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.RescanRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Rescan", []interface{}{arg1, arg2, arg3})
	fake.rescanMutex.Unlock()
	if fake.RescanStub != nil {
		return fake.RescanStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.rescanReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) RescanCallCount() int {
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	return len(fake.rescanArgsForCall)
}

func (fake *FakeWalletServiceClient) RescanCalls(stub func(context.Context, *walletrpc.RescanRequest, ...grpc.CallOption) (*walletrpc.RescanResponse, error)) {
	fake.rescanMutex.Lock()
	defer fake.rescanMutex.Unlock()
	fake.RescanStub = stub
}

func (fake *FakeWalletServiceClient) RescanArgsForCall(i int) (context.Context, *walletrpc.RescanRequest, []grpc.CallOption) {
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	argsForCall := fake.rescanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) RescanReturns(result1 *walletrpc.RescanResponse, result2 error) {
	fake.rescanMutex.Lock()
	defer fake.rescanMutex.Unlock()
	fake.RescanStub = nil
	fake.rescanReturns = struct {
		result1 *walletrpc.RescanResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) RescanReturnsOnCall(i int, result1 *walletrpc.RescanResponse, result2 error) {
	fake.rescanMutex.Lock()
	defer fake.rescanMutex.Unlock()
	fake.RescanStub = nil
	if fake.rescanReturnsOnCall == nil {
		fake.rescanReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.RescanResponse
			result2 error
		})
	}
	fake.rescanReturnsOnCall[i] = struct {
		result1 *walletrpc.RescanResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) RescanNotifications(arg1 context.Context, arg2 *walletrpc.RescanNotificationsRequest, arg3 ...grpc.CallOption) (walletrpc.WalletService_RescanNotificationsClient, error) {
	fake.rescanNotificationsMutex.Lock()
	ret, specificReturn := fake.rescanNotificationsReturnsOnCall[len(fake.rescanNotificationsArgsForCall)]
	fake.rescanNotificationsArgsForCall = append(fake.rescanNotificationsArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.RescanNotificationsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("RescanNotifications", []interface{}{arg1, arg2, arg3})
	fake.rescanNotificationsMutex.Unlock()
	if fake.RescanNotificationsStub != nil {
		return fake.RescanNotificationsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.rescanNotificationsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) RescanNotificationsCallCount() int {
	fake.rescanNotificationsMutex.RLock()
	defer fake.rescanNotificationsMutex.RUnlock()
	return len(fake.rescanNotificationsArgsForCall)
}

func (fake *FakeWalletServiceClient) RescanNotificationsCalls(stub func(context.Context, *walletrpc.RescanNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_RescanNotificationsClient, error)) {
	fake.rescanNotificationsMutex.Lock()
	defer fake.rescanNotificationsMutex.Unlock()
	fake.RescanNotificationsStub = stub
}

func (fake *FakeWalletServiceClient) RescanNotificationsArgsForCall(i int) (context.Context, *walletrpc.RescanNotificationsRequest, []grpc.CallOption) {
	fake.rescanNotificationsMutex.RLock()
	defer fake.rescanNotificationsMutex.RUnlock()
	argsForCall := fake.rescanNotificationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) RescanNotificationsReturns(result1 walletrpc.WalletService_RescanNotificationsClient, result2 error) {
	fake.rescanNotificationsMutex.Lock()
	defer fake.rescanNotificationsMutex.Unlock()
	fake.RescanNotificationsStub = nil
	fake.rescanNotificationsReturns = struct {
		result1 walletrpc.WalletService_RescanNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) RescanNotificationsReturnsOnCall(i int, result1 walletrpc.WalletService_RescanNotificationsClient, result2 error) {
	fake.rescanNotificationsMutex.Lock()
	defer fake.rescanNotificationsMutex.Unlock()
	fake.RescanNotificationsStub = nil
	if fake.rescanNotificationsReturnsOnCall == nil {
		fake.rescanNotificationsReturnsOnCall = make(map[int]struct {
			result1 walletrpc.WalletService_RescanNotificationsClient
			result2 error
		})
	}
	fake.rescanNotificationsReturnsOnCall[i] = struct {
		result1 walletrpc.WalletService_RescanNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) SignTransaction(arg1 context.Context, arg2 *walletrpc.SignTransactionRequest, arg3 ...grpc.CallOption) (*walletrpc.SignTransactionResponse, error) {
	fake.signTransactionMutex.Lock()
	ret, specificReturn := fake.signTransactionReturnsOnCall[len(fake.signTransactionArgsForCall)]
	fake.signTransactionArgsForCall = append(fake.signTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.SignTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("SignTransaction", []interface{}{arg1, arg2, arg3})
	fake.signTransactionMutex.Unlock()
	if fake.SignTransactionStub != nil {
		return fake.SignTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.signTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) SignTransactionCallCount() int {
	fake.signTransactionMutex.RLock()
	defer fake.signTransactionMutex.RUnlock()
	return len(fake.signTransactionArgsForCall)
}

func (fake *FakeWalletServiceClient) SignTransactionCalls(stub func(context.Context, *walletrpc.SignTransactionRequest, ...grpc.CallOption) (*walletrpc.SignTransactionResponse, error)) {
	fake.signTransactionMutex.Lock()
	defer fake.signTransactionMutex.Unlock()
	fake.SignTransactionStub = stub
}

func (fake *FakeWalletServiceClient) SignTransactionArgsForCall(i int) (context.Context, *walletrpc.SignTransactionRequest, []grpc.CallOption) {
	fake.signTransactionMutex.RLock()
	defer fake.signTransactionMutex.RUnlock()
	argsForCall := fake.signTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) SignTransactionReturns(result1 *walletrpc.SignTransactionResponse, result2 error) {
	fake.signTransactionMutex.Lock()
	defer fake.signTransactionMutex.Unlock()
	fake.SignTransactionStub = nil
	fake.signTransactionReturns = struct {
		result1 *walletrpc.SignTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) SignTransactionReturnsOnCall(i int, result1 *walletrpc.SignTransactionResponse, result2 error) {
	fake.signTransactionMutex.Lock()
	defer fake.signTransactionMutex.Unlock()
	fake.SignTransactionStub = nil
	if fake.signTransactionReturnsOnCall == nil {
		fake.signTransactionReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.SignTransactionResponse
			result2 error
		})
	}
	fake.signTransactionReturnsOnCall[i] = struct {
		result1 *walletrpc.SignTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) SpentnessNotifications(arg1 context.Context, arg2 *walletrpc.SpentnessNotificationsRequest, arg3 ...grpc.CallOption) (walletrpc.WalletService_SpentnessNotificationsClient, error) {
	fake.spentnessNotificationsMutex.Lock()
	ret, specificReturn := fake.spentnessNotificationsReturnsOnCall[len(fake.spentnessNotificationsArgsForCall)]
	fake.spentnessNotificationsArgsForCall = append(fake.spentnessNotificationsArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.SpentnessNotificationsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("SpentnessNotifications", []interface{}{arg1, arg2, arg3})
	fake.spentnessNotificationsMutex.Unlock()
	if fake.SpentnessNotificationsStub != nil {
		return fake.SpentnessNotificationsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.spentnessNotificationsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) SpentnessNotificationsCallCount() int {
	fake.spentnessNotificationsMutex.RLock()
	defer fake.spentnessNotificationsMutex.RUnlock()
	return len(fake.spentnessNotificationsArgsForCall)
}

func (fake *FakeWalletServiceClient) SpentnessNotificationsCalls(stub func(context.Context, *walletrpc.SpentnessNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_SpentnessNotificationsClient, error)) {
	fake.spentnessNotificationsMutex.Lock()
	defer fake.spentnessNotificationsMutex.Unlock()
	fake.SpentnessNotificationsStub = stub
}

func (fake *FakeWalletServiceClient) SpentnessNotificationsArgsForCall(i int) (context.Context, *walletrpc.SpentnessNotificationsRequest, []grpc.CallOption) {
	fake.spentnessNotificationsMutex.RLock()
	defer fake.spentnessNotificationsMutex.RUnlock()
	argsForCall := fake.spentnessNotificationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) SpentnessNotificationsReturns(result1 walletrpc.WalletService_SpentnessNotificationsClient, result2 error) {
	fake.spentnessNotificationsMutex.Lock()
	defer fake.spentnessNotificationsMutex.Unlock()
	fake.SpentnessNotificationsStub = nil
	fake.spentnessNotificationsReturns = struct {
		result1 walletrpc.WalletService_SpentnessNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) SpentnessNotificationsReturnsOnCall(i int, result1 walletrpc.WalletService_SpentnessNotificationsClient, result2 error) {
	fake.spentnessNotificationsMutex.Lock()
	defer fake.spentnessNotificationsMutex.Unlock()
	fake.SpentnessNotificationsStub = nil
	if fake.spentnessNotificationsReturnsOnCall == nil {
		fake.spentnessNotificationsReturnsOnCall = make(map[int]struct {
			result1 walletrpc.WalletService_SpentnessNotificationsClient
			result2 error
		})
	}
	fake.spentnessNotificationsReturnsOnCall[i] = struct {
		result1 walletrpc.WalletService_SpentnessNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) SweepAccount(arg1 context.Context, arg2 *walletrpc.SweepAccountRequest, arg3 ...grpc.CallOption) (*walletrpc.SweepAccountResponse, error) {
	fake.sweepAccountMutex.Lock()
	ret, specificReturn := fake.sweepAccountReturnsOnCall[len(fake.sweepAccountArgsForCall)]
	fake.sweepAccountArgsForCall = append(fake.sweepAccountArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.SweepAccountRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("SweepAccount", []interface{}{arg1, arg2, arg3})
	fake.sweepAccountMutex.Unlock()
	if fake.SweepAccountStub != nil {
		return fake.SweepAccountStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.sweepAccountReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) SweepAccountCallCount() int {
	fake.sweepAccountMutex.RLock()
	defer fake.sweepAccountMutex.RUnlock()
	return len(fake.sweepAccountArgsForCall)
}

func (fake *FakeWalletServiceClient) SweepAccountCalls(stub func(context.Context, *walletrpc.SweepAccountRequest, ...grpc.CallOption) (*walletrpc.SweepAccountResponse, error)) {
	fake.sweepAccountMutex.Lock()
	defer fake.sweepAccountMutex.Unlock()
	fake.SweepAccountStub = stub
}

func (fake *FakeWalletServiceClient) SweepAccountArgsForCall(i int) (context.Context, *walletrpc.SweepAccountRequest, []grpc.CallOption) {
	fake.sweepAccountMutex.RLock()
	defer fake.sweepAccountMutex.RUnlock()
	argsForCall := fake.sweepAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) SweepAccountReturns(result1 *walletrpc.SweepAccountResponse, result2 error) {
	fake.sweepAccountMutex.Lock()
	defer fake.sweepAccountMutex.Unlock()
	fake.SweepAccountStub = nil
	fake.sweepAccountReturns = struct {
		result1 *walletrpc.SweepAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) SweepAccountReturnsOnCall(i int, result1 *walletrpc.SweepAccountResponse, result2 error) {
	fake.sweepAccountMutex.Lock()
	defer fake.sweepAccountMutex.Unlock()
	fake.SweepAccountStub = nil
	if fake.sweepAccountReturnsOnCall == nil {
		fake.sweepAccountReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.SweepAccountResponse
			result2 error
		})
	}
	fake.sweepAccountReturnsOnCall[i] = struct {
		result1 *walletrpc.SweepAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) TransactionNotifications(arg1 context.Context, arg2 *walletrpc.TransactionNotificationsRequest, arg3 ...grpc.CallOption) (walletrpc.WalletService_TransactionNotificationsClient, error) {
	fake.transactionNotificationsMutex.Lock()
	ret, specificReturn := fake.transactionNotificationsReturnsOnCall[len(fake.transactionNotificationsArgsForCall)]
	fake.transactionNotificationsArgsForCall = append(fake.transactionNotificationsArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.TransactionNotificationsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("TransactionNotifications", []interface{}{arg1, arg2, arg3})
	fake.transactionNotificationsMutex.Unlock()
	if fake.TransactionNotificationsStub != nil {
		return fake.TransactionNotificationsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.transactionNotificationsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) TransactionNotificationsCallCount() int {
	fake.transactionNotificationsMutex.RLock()
	defer fake.transactionNotificationsMutex.RUnlock()
	return len(fake.transactionNotificationsArgsForCall)
}

func (fake *FakeWalletServiceClient) TransactionNotificationsCalls(stub func(context.Context, *walletrpc.TransactionNotificationsRequest, ...grpc.CallOption) (walletrpc.WalletService_TransactionNotificationsClient, error)) {
	fake.transactionNotificationsMutex.Lock()
	defer fake.transactionNotificationsMutex.Unlock()
	fake.TransactionNotificationsStub = stub
}

func (fake *FakeWalletServiceClient) TransactionNotificationsArgsForCall(i int) (context.Context, *walletrpc.TransactionNotificationsRequest, []grpc.CallOption) {
	fake.transactionNotificationsMutex.RLock()
	defer fake.transactionNotificationsMutex.RUnlock()
	argsForCall := fake.transactionNotificationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) TransactionNotificationsReturns(result1 walletrpc.WalletService_TransactionNotificationsClient, result2 error) {
	fake.transactionNotificationsMutex.Lock()
	defer fake.transactionNotificationsMutex.Unlock()
	fake.TransactionNotificationsStub = nil
	fake.transactionNotificationsReturns = struct {
		result1 walletrpc.WalletService_TransactionNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) TransactionNotificationsReturnsOnCall(i int, result1 walletrpc.WalletService_TransactionNotificationsClient, result2 error) {
	fake.transactionNotificationsMutex.Lock()
	defer fake.transactionNotificationsMutex.Unlock()
	fake.TransactionNotificationsStub = nil
	if fake.transactionNotificationsReturnsOnCall == nil {
		fake.transactionNotificationsReturnsOnCall = make(map[int]struct {
			result1 walletrpc.WalletService_TransactionNotificationsClient
			result2 error
		})
	}
	fake.transactionNotificationsReturnsOnCall[i] = struct {
		result1 walletrpc.WalletService_TransactionNotificationsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) ValidateAddress(arg1 context.Context, arg2 *walletrpc.ValidateAddressRequest, arg3 ...grpc.CallOption) (*walletrpc.ValidateAddressResponse, error) {
	fake.validateAddressMutex.Lock()
	ret, specificReturn := fake.validateAddressReturnsOnCall[len(fake.validateAddressArgsForCall)]
	fake.validateAddressArgsForCall = append(fake.validateAddressArgsForCall, struct {
		arg1 context.Context
		arg2 *walletrpc.ValidateAddressRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("ValidateAddress", []interface{}{arg1, arg2, arg3})
	fake.validateAddressMutex.Unlock()
	if fake.ValidateAddressStub != nil {
		return fake.ValidateAddressStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.validateAddressReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWalletServiceClient) ValidateAddressCallCount() int {
	fake.validateAddressMutex.RLock()
	defer fake.validateAddressMutex.RUnlock()
	return len(fake.validateAddressArgsForCall)
}

func (fake *FakeWalletServiceClient) ValidateAddressCalls(stub func(context.Context, *walletrpc.ValidateAddressRequest, ...grpc.CallOption) (*walletrpc.ValidateAddressResponse, error)) {
	fake.validateAddressMutex.Lock()
	defer fake.validateAddressMutex.Unlock()
	fake.ValidateAddressStub = stub
}

func (fake *FakeWalletServiceClient) ValidateAddressArgsForCall(i int) (context.Context, *walletrpc.ValidateAddressRequest, []grpc.CallOption) {
	fake.validateAddressMutex.RLock()
	defer fake.validateAddressMutex.RUnlock()
	argsForCall := fake.validateAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWalletServiceClient) ValidateAddressReturns(result1 *walletrpc.ValidateAddressResponse, result2 error) {
	fake.validateAddressMutex.Lock()
	defer fake.validateAddressMutex.Unlock()
	fake.ValidateAddressStub = nil
	fake.validateAddressReturns = struct {
		result1 *walletrpc.ValidateAddressResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) ValidateAddressReturnsOnCall(i int, result1 *walletrpc.ValidateAddressResponse, result2 error) {
	fake.validateAddressMutex.Lock()
	defer fake.validateAddressMutex.Unlock()
	fake.ValidateAddressStub = nil
	if fake.validateAddressReturnsOnCall == nil {
		fake.validateAddressReturnsOnCall = make(map[int]struct {
			result1 *walletrpc.ValidateAddressResponse
			result2 error
		})
	}
	fake.validateAddressReturnsOnCall[i] = struct {
		result1 *walletrpc.ValidateAddressResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeWalletServiceClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.accountNotificationsMutex.RLock()
	defer fake.accountNotificationsMutex.RUnlock()
	fake.accountNumberMutex.RLock()
	defer fake.accountNumberMutex.RUnlock()
	fake.accountsMutex.RLock()
	defer fake.accountsMutex.RUnlock()
	fake.balanceMutex.RLock()
	defer fake.balanceMutex.RUnlock()
	fake.changePassphraseMutex.RLock()
	defer fake.changePassphraseMutex.RUnlock()
	fake.createTransactionMutex.RLock()
	defer fake.createTransactionMutex.RUnlock()
	fake.currentAddressMutex.RLock()
	defer fake.currentAddressMutex.RUnlock()
	fake.downloadPaymentRequestMutex.RLock()
	defer fake.downloadPaymentRequestMutex.RUnlock()
	fake.fundTransactionMutex.RLock()
	defer fake.fundTransactionMutex.RUnlock()
	fake.getTransactionsMutex.RLock()
	defer fake.getTransactionsMutex.RUnlock()
	fake.importPrivateKeyMutex.RLock()
	defer fake.importPrivateKeyMutex.RUnlock()
	fake.networkMutex.RLock()
	defer fake.networkMutex.RUnlock()
	fake.nextAccountMutex.RLock()
	defer fake.nextAccountMutex.RUnlock()
	fake.nextAddressMutex.RLock()
	defer fake.nextAddressMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.postPaymentMutex.RLock()
	defer fake.postPaymentMutex.RUnlock()
	fake.publishTransactionMutex.RLock()
	defer fake.publishTransactionMutex.RUnlock()
	fake.renameAccountMutex.RLock()
	defer fake.renameAccountMutex.RUnlock()
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	fake.rescanNotificationsMutex.RLock()
	defer fake.rescanNotificationsMutex.RUnlock()
	fake.signTransactionMutex.RLock()
	defer fake.signTransactionMutex.RUnlock()
	fake.spentnessNotificationsMutex.RLock()
	defer fake.spentnessNotificationsMutex.RUnlock()
	fake.sweepAccountMutex.RLock()
	defer fake.sweepAccountMutex.RUnlock()
	fake.transactionNotificationsMutex.RLock()
	defer fake.transactionNotificationsMutex.RUnlock()
	fake.validateAddressMutex.RLock()
	defer fake.validateAddressMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWalletServiceClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ walletrpc.WalletServiceClient = new(FakeWalletServiceClient)
